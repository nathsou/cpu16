module Top (
    clk: input clock,
    btn_r: input logic,
    led: output logic<16>,
    seg: output logic<7>,
    an: output logic<8>,
    dp: output logic,
    vga_hs: output logic,
    vga_vs: output logic,
    vga_r: output logic<4>,
    vga_g: output logic<4>,
    vga_b: output logic<4>,
    // uart_rx: output logic,
    uart_tx: input logic,
    sw: input logic<16>,
    led16_b: output logic,
    led16_g: output logic,
    led16_r: output logic,
    pmod_jd1: output logic,
    pmod_jd2: output logic,
) {
    var rst: reset;

    enum Mode: logic {
        execute,
        program,
    }

    inst reset_conditioner: ResetConditioner #(
        Stages: 4,
    ) (
        i_clk: clk,
        i_in: btn_r,
        o_out: rst,
    );

    var program_counter: logic<16>;
    var display_reg: logic<32>;
    var halt_flag: bit;
    var zero_flag: bit;
    var carry_flag: bit;

    var ram_write_enable: logic;
    var ram_address: logic<16>;
    var ram_write_data: logic<16>;
    var ram_read_data: logic<16>;

    inst ram: RAM (
        i_clk: clk,
        i_write_enable: ram_write_enable,
        i_address: ram_address,
        i_write_data: ram_write_data,
        o_read_data: ram_read_data,
    );

    var w_uart_ready: logic;
    var w_uart_data: logic<8>;
    var r_uart_data: logic<8>;
    let mode: logic = if sw[0] { Mode::program } else { Mode::execute };
    var w_uart_state: logic<2>;

    always_ff (clk) {
        if rst {
            r_uart_data = '0;
        } else if w_uart_ready == 1'b1 {
            r_uart_data = w_uart_data;
        }
    }

    inst uart: UART (
        i_clk: clk,
        i_uart_rx: uart_tx,
        o_ready: w_uart_ready,
        o_data: w_uart_data,
        o_state: w_uart_state,
    );

    inst cpu: CPU (
        i_clk: clk,
        i_rst: rst,
        i_nmi: 1'b0,
        i_ram_read_data: ram_read_data,
        o_display_reg: display_reg,
        o_program_counter: program_counter,
        o_halt_flag: halt_flag,
        o_zero_flag: zero_flag,
        o_carry_flag: carry_flag,
        o_ram_write_enable: ram_write_enable,
        o_ram_write_data: ram_write_data,
        o_ram_address: ram_address,
    );

    let name_table_write_data: logic<16> = ram_write_data;
    var name_table_write_addr: logic<13>;
    let name_table_write_enable: bit = ram_write_enable && ram_address == 16'hffff;

    // Memory-mapped I/O
    always_ff (clk) {
        if rst {
            name_table_write_addr = 13'h0;
        } else if ram_write_enable {
            case ram_address {
                16'hfffe: {
                    name_table_write_addr = ram_write_data[12:0];
                }
                16'hffff: {
                    name_table_write_addr = name_table_write_addr + 1;
                }
                default: {}
            }
        }
    }

    inst ppu: PPU (
        i_clk_100mhz: clk,
        i_rst: rst,
        i_name_table_write_enable: name_table_write_enable,
        i_name_table_write_data: name_table_write_data,
        i_name_table_write_addr: name_table_write_addr,
        o_hsync: vga_hs,
        o_vsync: vga_vs,
        o_vga_red: vga_r,
        o_vga_green: vga_g,
        o_vga_blue: vga_b,
    );

    inst display: SevenSegment (
        i_clk: clk,
        i_value: if mode == Mode::execute { display_reg } else { r_uart_data },
        o_seg: seg,
        o_an: an,
        o_dp: dp,
    );

    assign led = if mode == Mode::execute { program_counter } else { {uart_tx, w_uart_ready, 13'd0, w_uart_state} };
    assign led16_b = sw[0];
    assign led16_g = sw[1];
    assign led16_r = sw[2];

    assign pmod_jd1 = clk;
    assign pmod_jd2 = uart_tx;
}
